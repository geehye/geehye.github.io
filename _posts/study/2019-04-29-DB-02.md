---
title: ""
date: 2019-04-29
layout:
tags: DataBase
---

## 1. Index 인덱스
- Definition 정의 : RDBMS에서 검색 속도를 높이기 위해 사용하는 자료 구조 (B-Tree 구조로 색인)
- Principle 원리 : 초기 테이블 생성시 만들어진 MYI 파일에 해당 컬럼을 색인하고, 검색 시 Tree로 정리해둔 MYI 파일의 내용을 검색한다.
만약 인덱스를 사용하지 않은 쿼리를 날리면, 해당 테이블을 full scan 한다.
- 인덱스 구조
  - 인덱스 탐색 : Root (Branch에 대한 정보) -> Branch (Leaf에 대한 정보) -> Leaf (데이터의 주소에 대한 정보) -> 디스크 저장소
  - 많은 인덱스로 인해 옵티마이저 Optimizer 가 잘못된 인덱스를 선택할 확률이 높아지므로 인덱스의 개수는 3~4개가 적당하다.
- 인덱스 키 값의 크기 : MySQL은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 하며 16KB로 크기가 고정된다. 
- Disadvantages 단점
  - 인덱스의 키가 길 수록 성능 저하
  - 인덱스 된 필드 field 에서 데이터를 업데이트하거나 레코드를 추가/삭제시 성능 저하
  - DB의 10% 내외로 인덱스 공간 필요
- 인덱스 컬럼 기준
  - WHERE절에서 사용되는 / 외래키가 사용되는 / JOIN에 자주 사용되는 / 바뀌지 않을 / 단일보다는 다중 '컬럼'
  - 한 개의 컬럼만 인덱스를 걸어야 한다면, 카디널리티 cardinality 가 가장 높은 것을 잡는다. (예. 성별, 학년 x -> 주민등록번호, 계좌번호 o)
  - 여러 개의 컬럼으로 인덱스를 걸어야 한다면, 카디널리티가 높은 순에서 낮은 순으로 구성한다.
  - 단일 컬럼보다는 다중 컬럼
- 인덱스 조회시 주의 사항
  - AND 연산자는 각 조건이 읽어야할 행의 수를 줄이지만, OR 연산자는 비교해야 할 행의 수가 늘어나기 때문에 full table scan 발생 확률이 높아진다.
  - 인덱스로 사용된 컬럼 값을 그대로 사용해야 된다. (가공하거나 연산해서는 안 된다.)
  - NULL을 비교값으로 사용한 경우에는 인덱스를 타지 않는다.

<br><br>
## 2. Transaction 트랜잭션
- Definition 정의 : 하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합
- Example 예시 : 한 계좌에서 10만원을 인출하여 다른 계좌로 10만원 입금하는 이체 작업은 전체 작업이 정상적으로 완료되거나, 만약 정상적으로 처리될 수 없는 경우에는 아무 것도 실행되지 않은 처음 상태로 되돌려져야 한다. 이러한 트랜잭션은 다양한 데이터 항목들을 액세스하고 갱신하는 프로그램 수행의 단위가 된다.
- Features 특징
  - Atomicity 원자성 : DBMS는 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다. 'All or Nothing'
  - Consistency 일관성 : 
  - Isolation 독립성 :
  - Durability 지속성 :



<br><br>
※ 참고 : https://lalwr.blogspot.com/2016/02/db-index.html, https://d2.naver.com/helloworld/407507
