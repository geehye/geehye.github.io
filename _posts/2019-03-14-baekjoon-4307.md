---
title: "Greedy 백준 알고리즘 자바 4307 '개미' 문제풀이"
date: 2019-03-14
layout:
tags: baekjoon
---


## Problem

## Solution
처음에 헉! 했던 문제. 하지만 찬찬히 읽어보면 답이 나온다. 그리디 문제는 뭔가 문제 속에 답이 있고, 그거를 얼마나 빨리 찾냐 못 찾냐 문제인 것 같다.
개미가 어느 방향으로 가는 지 모른다, 반대로 바꾸어 갈 수도 있다. 이런 말들 때문에 혼란이 왔지만, 그리디는 뭔가 엄청난 예외사항을 찾을 필요가 없고 그래서도 안 된다.

우선 정말 간단하게, 가장 빨리 모든 개미가 떨어지는 시간은 모든 개미가 자신과 가장 가까운 막대 끝쪽으로 가면 된다. 즉, 막대기의 절반 L/2를 기준으로 개미의 현 위치가 이보다 크면 막대기 끝쪽으로 가면 되고, 이보다 작으면 막대기의 앞부분으로 가면 된다.
따라서 막대기 끝부분으로 가야하는 개미 중 가장 작은 값이 막대기 끝에서 가장 먼 개미이고 (L - min이 걸리시는 시간), 앞부분으로 가야하는 개미 중 가장 큰 값이 막대기 앞에서 가장 먼 개미이다. (max가 걸린 시간) 이 중 큰 값이 가장 빨리 떨어지는 시간이다. (읭? :))
가장 오래 걸리는 방법은 막대기 끝으로 가야하는 애가 막대기 앞으로 오거나 막대기 앞으로 가야하는 애가 막대기 끝으로 가는 경우이다.
그래서 정렬을 했다. 이제 연산하면 끝!



## Code
<pre>
import java.util.Arrays;
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int tc = scan.nextInt(), l, n, min, max;
		
		for(int i = 0; i < tc; i++) {
			l = scan.nextInt(); n = scan.nextInt();
			int[] points = new int[n];
			min = 1000000; max = 0;
			
			for(int j = 0; j < n; j++) {
				points[j] = scan.nextInt();
				if(points[j] >= l/2)
					min = Math.min(min, points[j]);
				else
					max = Math.max(max, points[j]);
			}
			Arrays.sort(points);
			System.out.println(Math.max(l - min, max) + " " + Math.max(l - points[0], points[n-1]));
		}
	}
}
